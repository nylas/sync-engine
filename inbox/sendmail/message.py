"""
When sending mail, Inbox tries to be a good citizen to the modern world.
This means everything we send is either ASCII or UTF-8.
That means no Latin-1 or ISO-8859-1.

All headers are converted to ASCII and if that doesn't work, UTF-8.

Note that plain text that's UTF-8 will be sent as base64. i.e.:
Content-Type: text/text; charset='utf-8'
Content-Transfer-Encoding: base64

This is because not all servers support 8BIT and so flanker drops to b64.
http://www.w3.org/Protocols/rfc1341/5_Content-Transfer-Encoding.html

"""
from collections import namedtuple
import pkg_resources

from flanker import mime
from flanker.addresslib import address
from html2text import html2text

from inbox.sqlalchemy_ext.util import generate_public_id

VERSION = pkg_resources.get_distribution('inbox').version

REPLYSTR = 'Re: '

Recipients = namedtuple('Recipients', 'to cc bcc')


def create_email(sender_name, sender_email, inbox_uid, recipients, subject,
                 html, attachments):
    """
    Creates a MIME email message (both body and sets the needed headers).

    Parameters
    ----------
    sender_name: string
        The name aka phrase of the sender.
    sender_email: string
        The sender's email address.
    recipients: Recipients(to, cc, bcc) namedtuple
        to, cc, bcc are a lists of utf-8 encoded strings or None.
    subject : string
        a utf-8 encoded string
    html : string
        a utf-8 encoded string
    attachments: list of dicts, optional
        a list of dicts(filename, data, content_type)

    """
    to = [address.EmailAddress(*addr) for addr in recipients.to] \
        if recipients.to else []
    cc = [address.EmailAddress(*addr) for addr in recipients.cc] \
        if recipients.cc else []
    bcc = [address.EmailAddress(*addr) for addr in recipients.bcc] \
        if recipients.bcc else []
    html = html if html else ''
    plaintext = html2text(html)

    # Create a multipart/alternative message
    msg = mime.create.multipart('alternative')
    msg.append(
        mime.create.text('text', plaintext),
        mime.create.text('html', html))

    # Create an outer multipart/mixed message
    if attachments:
        text_msg = msg
        msg = mime.create.multipart('mixed')

        # The first part is the multipart/alternative text part
        msg.append(text_msg)

        # The subsequent parts are the attachment parts
        for a in attachments:
            # Disposition should be inline if we add Content-ID
            msg.append(mime.create.attachment(
                a['content_type'],
                a['data'],
                filename=a['filename'],
                disposition='attachment'))

    msg.headers['Subject'] = subject if subject else ''

    # Gmail sets the From: header to the default sending account. We can
    # however set our own custom phrase i.e. the name that appears next to the
    # email address (useful if the user has multiple aliases and wants to
    # specify which to send as), see: http://lee-phillips.org/gmailRewriting/
    # For other providers, we simply use name = ''
    from_addr = address.EmailAddress(sender_name, sender_email)
    msg.headers['From'] = from_addr.full_spec()

    # Need to set these headers so recipients know we sent the email to them:

    # Note also that the To: header has different semantics than the envelope
    # recipient. For example, you can use '"Tony Meyer" <tony.meyer@gmail.com>'
    # as an address in the To: header, but the envelope recipient must be only
    # 'tony.meyer@gmail.com'.
    msg.headers['To'] = u', '.join([addr.full_spec() for addr in to])
    msg.headers['Cc'] = u', '.join([addr.full_spec() for addr in cc])
    msg.headers['Bcc'] = u', '.join([addr.full_spec() for addr in bcc])

    add_inbox_headers(msg, inbox_uid)

    return msg


def add_inbox_headers(msg, inbox_uid):
    """
    Set a custom `X-INBOX-ID` header so as to identify messages generated by
    Inbox.

    The header is set to a unique id generated randomly per message,
    and is needed for the correct reconciliation of sent messages on
    future syncs.

    Notes
    -----
    We generate the UUID as a base-36 encoded string, and is the same as the
    public_id of the message object.

    """
    # Set our own custom header for tracking in `Sent Mail` folder
    msg.headers['X-INBOX-ID'] = inbox_uid if inbox_uid else \
        generate_public_id()  # base-36 encoded string

    # Potentially also use `X-Mailer`
    msg.headers['User-Agent'] = 'Inbox/{0}'.format(VERSION)


def rfc_transform(msg):
    """ Create an RFC-2821 compliant SMTP message. """
    msgstring = msg.to_string()

    start = msgstring.find('References: ')

    if start == -1:
        return msgstring

    end = msgstring.find('\r\n', start + len('References: '))

    substring = msgstring[start:end]

    separator = '\n\t'
    rfcmsg = msgstring[:start] + substring.replace('\t', separator) +\
        msgstring[end:]

    return rfcmsg
